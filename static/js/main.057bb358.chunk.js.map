{"version":3,"sources":["wall.tsx","tools.ts","app.tsx","reportWebVitals.ts","index.tsx"],"names":["Square","coreSquare","index","onChange","onSelect","className","type","value","clue","event","target","selected","solvedGroup","onClick","Error","Wall","coreSquares","map","cs","toString","DumbEncrypt","val","encrypted","this","prime","Math","floor","random","undoInt","groupFromIndex","CoreSquare","answerGroup","cluesSetByURL","startingSquares","positionSquaresInSolvedGroup","squares","groupNo","groupBeingProcessed","length","positional","current","sanityCheckSolvedGroups","moveTo","findIndex","s","urlParams","URLSearchParams","window","location","search","urlClues","get","clues","split","groupSize","console","log","unpackURLClues","urlSolutionGroups","values","urlKey","combinedValues","parseInt","i","push","reverse","g","filter","k","unpackURLSolutionGroups","alert","n","processURLParams","App","useState","setCoreSquares","lastSolvedGroup","setLastSolvedGroup","find","forEach","every","newClue","newSquares","replace","append","slice","key","doInt","makeUrlParams","array","j","shuffleArray","open","href","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"oOAgBMA,EAA2B,SAAC,GAA0D,IAAzDC,EAAwD,EAAxDA,WAAYC,EAA4C,EAA5CA,MAAOC,EAAqC,EAArCA,SAAUC,EAA2B,EAA3BA,SAE5D,GAAID,EAAU,CAKV,OACI,qBAAKE,UAAU,SAAf,SACI,uBAAOC,KAAK,OAAOC,MAAON,EAAWO,KAAML,SANR,SAACM,GACxCN,EAASD,EAAOO,EAAMC,OAAOH,YAShC,GAAIH,EAAU,CACf,IAIIC,EAAU,SAQd,OAPGJ,EAAWU,WACVN,GAAa,aAEdJ,EAAWW,cACVP,GAAa,SAAWJ,EAAWW,aAInC,qBACIC,QAdoB,WACxBT,EAASF,IAcLG,UAAWA,EAFf,SAIKJ,EAAWO,OAKpB,MAAMM,MAAM,SA2BLC,EAhBa,SAAC,GAAoD,IAAlDC,EAAiD,EAAjDA,YAAab,EAAoC,EAApCA,SAAUC,EAA0B,EAA1BA,SAClD,OACI,qBAAKC,UAAU,OAAf,SACKW,EAAYC,KAAI,SAACC,EAAgBhB,GAAjB,OACb,cAAC,EAAD,CAEIA,MAAOA,EACPD,WAAYiB,EACZf,SAAUA,EACVC,SAAUA,GAJLF,EAAMiB,kB,OC1DxB,IAAOC,EAAd,mGAGiBC,GACX,IAAMC,EAAYD,EAAME,KAAKC,MAC3BC,KAAKC,MAAMD,KAAKE,SAAWJ,KAAKC,OAElC,GAAGD,KAAKK,QAAQN,KAAeD,EAC7B,MAAM,IAAIP,MAAJ,0CAA6CO,IAErD,OAAOC,IAVb,8BAamBD,GACb,OAAOI,KAAKC,MAAML,EAAME,KAAKC,WAdnC,KAAcJ,EACeI,MAAQ,M,MCarC,SAASK,EAAe3B,GACtB,OAAOuB,KAAKC,MAAMxB,EALF,GAKqB,E,IAGjC4B,EAMJ,WAAYC,GAA+B,IAAVvB,EAAS,uDAAJ,GAAI,yBALjCuB,iBAKiC,OAJ1CvB,UAI0C,OAH1CG,UAAW,EAG+B,KAF1CC,YAA6B,KAG3BW,KAAKQ,YAAcA,EACnBR,KAAKf,KAAOA,GAmEhB,IACIwB,EADAC,EAAqC,GA8DzC,SAASC,EAA6BC,EAA4BC,IAhBlE,SAAiCD,EAA4BE,GAC3D,IAAK,IAAInC,EAAQ,EAAGA,EAAQiC,EAAQG,SAAUpC,EAAO,CACnD,IAAMqC,EAAaV,EAAe3B,GAC5BsC,EAAUL,EAAQjC,GAAOU,YAC/B,GAAG2B,EAAaF,EAAqB,CACjC,GAAGE,IAAeC,EAChB,MAAM,IAAI1B,MAAJ,iBAAoBZ,EAApB,mCAAoDqC,IAG5D,GAAIC,EAAUH,EACZ,MAAM,IAAIvB,MAAJ,iBAAoBZ,EAApB,yCAA0DsC,MAQxEC,CAAwBN,EAASC,GAGjC,IAAK,IAAIlC,EAAQ,EAAGA,EAAQiC,EAAQG,SAAUpC,EAAO,CAEnD,GADWiC,EAAQjC,GACZU,cAAgBwB,GAAWP,EAAe3B,KAAWkC,EAAS,CACnE,IAAMM,EAASP,EAAQQ,WAAU,SAAAC,GAAC,OAAKA,EAAEhC,eACzC,GAAIiB,EAAea,KAAYN,EAC7B,MAAM,IAAItB,MAAM,iCAHiD,MAK/B,CAACqB,EAAQO,GAASP,EAAQjC,IAA7DiC,EAAQjC,GAL0D,KAKlDiC,EAAQO,GAL0C,QAlEzE,WAEI,IAAMG,EAAY,IAAIC,gBAAgBC,OAAOC,SAASC,QAEhDC,EArDV,SAAwBL,GAEtB,IAAMK,EAAWL,EAAUM,IAAI,SAC/B,GAAGD,EAAU,CACX,IAAME,EAAQF,EAASG,MAAM,KAE7B,GAzCaC,KAyCVF,EAAMd,OACP,OAAOc,EAEPG,QAAQC,IAAI,4CAA6CJ,GAG7D,OAAO,KAyCYK,CAAeZ,GAC1Ba,EAvCV,SAAiCb,GAC/B,IAAIc,EAA+B,KAE7BC,EAASf,EAAUM,IAAI,OAC7B,GAAIS,EAAQ,CAEV,IAAIC,EAAiBzC,EAAYQ,QAAQkC,SAASF,IAElDD,EAAS,GACT,IAAK,IAAII,EAAI,EAAGA,EA3DHT,KA2DmBS,EAAG,CACjC,IAAMxD,EAAQsD,EA7DJ,EA8DVA,GAAkBA,EAAiBtD,GA9DzB,EA+DVoD,EAAOK,KAAKzD,GAEdoD,EAAOM,UAGP,IAbU,eAaDC,GArEK,IAsEIP,EAAOQ,QAAO,SAAAC,GAAC,OAAIA,IAAMF,KAC7B5B,SACViB,QAAQC,IAAI,0BAA2BI,GACvCD,EAAS,OAJJO,EAAI,EAAGP,GAAUO,EApEd,IAoE6BA,EAAI,EAApCA,GAQTX,QAAQC,IAAI,eAAgBG,GAG9B,OAAOA,EAWqBU,CAAwBxB,GAGlD,GADAb,GAAgB,EACbkB,GAAYQ,EAAmB,CAChC1B,GAAgB,EAEhB,IAAI,IAAI+B,EAAI,EAAGA,EA/FJT,KA+FoBS,EAC7B9B,EAAgB+B,KACd,IAAIlC,EAAW4B,EAAkBK,GAAIb,EAASa,SAI/C,CACAlB,EAAU1B,YACXmD,MAAM,uCAGR,IAAK,IAAIlC,EAAU,EAAGA,EA3GZ,IA2GiCA,EACzC,IAAK,IAAImC,EAAI,EAAGA,EA7GN,IA6GuBA,EAAG,CAClC,IAAI3B,EAAI,IAAId,EAAWM,GACvBH,EAAgB+B,KAAKpB,KAW/B4B,GAyCA,IA2EeC,EA3EK,WAAO,IAAD,EAEcC,mBAASzC,GAFvB,mBAEjBjB,EAFiB,KAEJ2D,EAFI,OAGsBD,mBAAS,GAH/B,mBAGjBE,EAHiB,KAGAC,EAHA,KAyDxB,OAAI7C,EAEA,qBAAK3B,UAAU,cAAf,SACE,cAAC,EAAD,CAAMW,YAAaA,EAAaZ,SA1CQ,SAACF,GAG7C,GAAG8B,IAAkBhB,EAAYd,GAAOU,YAAa,CACnD,IAAIuB,EAAO,YAAOnB,GAClBmB,EAAQjC,GAAOS,UAAYwB,EAAQjC,GAAOS,SAE1C,IAAIA,EAAWwB,EAAQgC,QAAO,SAAAjD,GAAE,OAAIA,EAAGP,YACvC,GAAGA,EAASmE,MAAK,SAAAlC,GAAC,OAAIA,EAAEhC,eACtB,MAAM,IAAIE,MAAM,qCAGlB,GAjMY,IAiMRH,EAAS2B,SACX3B,EAASoE,SAAQ,SAAAnC,GAAC,OAAIA,EAAEjC,UAAW,KAE/BA,EAASqE,OAAM,SAAApC,GAAC,OAAIA,EAAEb,cAAgBpB,EAAS,GAAGoB,gBAAc,CAClE,IAAMnB,EAAcgE,EAAkB,EACtCC,EAAmBjE,GAEnBD,EAASoE,SAAQ,SAAAnC,GAAC,OAAIA,EAAEhC,YAAcA,KACtCsB,EAA6BC,EAASvB,GAInCA,EAAc,IA5MX,IA6MJuB,EAAQ4C,SAAQ,SAAAnC,GACVA,EAAEhC,cACJgC,EAAEhC,YA/MF,MAkNJiE,EAlNI,IAuNVF,EAAexC,SAYf,sBAAK9B,UAAU,cAAf,UACE,cAAC,EAAD,CAAMW,YAAaA,EAAab,SA7DuB,SAACD,EAAO+E,GACnE,IAAIC,EAAU,YAAOlE,GACrBkE,EAAWhF,GAAOM,KAAkByE,EArL1BE,QAAQ,KAAM,IAsLxBR,EAAeO,MA2DX,qBAAK7E,UAAU,WAAf,SACE,wBAAQC,KAAK,SAASO,QAzDY,WACxC,IACMgC,EA3JV,SAAuBV,GAErB,IAAIU,EAAY,IAAIC,gBAEhBM,EAAM,GACVjB,EAAQ4C,SAAQ,SAAAnC,GAAC,OAAIQ,GAASR,EAAEpC,KAAO,OACvCqC,EAAUuC,OAAO,QAAShC,EAAMiC,MAAM,GAAI,IAE1C9B,QAAQC,IAAI,sBAAuBrB,EAAQlB,KAAI,SAAA2B,GAAC,OAAKA,EAAEb,gBACvD,IAAIuD,EAAM,EACVnD,EAAQ4C,SAAQ,SAAAnC,GAAC,OAAI0C,EA9BP,EA8BaA,EAAgB1C,EAAEb,eAC7C,IAAMT,EAAYF,EAAYmE,MAAMD,GAEpC,OADAzC,EAAUuC,OAAO,MAAO9D,EAAUH,YAC3B0B,EA8Ia2C,CDnMf,SAAyBC,GAE5B,IAAK,IAAI1B,EAAI0B,EAAMnD,OAAS,EAAGyB,EAAI,EAAGA,IAAK,CACvC,IAAM2B,EAAIjE,KAAKC,MAAMD,KAAKE,UAAYoC,EAAI,IADH,EAEhB,CAAC0B,EAAMC,GAAID,EAAM1B,IAAvC0B,EAAM1B,GAFgC,KAE5B0B,EAAMC,GAFsB,KAI3C,OAAOD,EC4LUE,CAAa,YAAI3E,KAGlC+B,OAAO6C,KAAK7C,OAAOC,SAAS6C,KAAO,IAAMhD,EAAU1B,aAqD7C,wBC7OK2E,EAZS,SAACC,GACnBA,GAAeA,aAAuBC,UACxC,6BAAqBC,MAAK,YAAkD,IAA/CC,EAA8C,EAA9CA,OAAQC,EAAsC,EAAtCA,OAAQC,EAA8B,EAA9BA,OAAQC,EAAsB,EAAtBA,OAAQC,EAAc,EAAdA,QAC3DJ,EAAOH,GACPI,EAAOJ,GACPK,EAAOL,GACPM,EAAON,GACPO,EAAQP,OCHdQ,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEFC,SAASC,eAAe,SAM1Bb,M","file":"static/js/main.057bb358.chunk.js","sourcesContent":["import React, { FC } from 'react';\r\n\r\n\r\ninterface CoreSquare {\r\n    clue: string;\r\n    selected: boolean;\r\n    solvedGroup: number | null;\r\n};\r\n\r\ninterface SquareProps {\r\n    coreSquare: CoreSquare;\r\n    index: number;\r\n    onChange?: (index: number, word: string) => void;\r\n    onSelect?: (index:number) => void;\r\n}\r\n\r\nconst Square : FC<SquareProps> = ({coreSquare, index, onChange, onSelect}: SquareProps) => {\r\n  \r\n    if (onChange) {\r\n        const onClueChange: (event: any) => void = (event) => {\r\n            onChange(index, event.target.value)\r\n        };\r\n\r\n        return (\r\n            <div className=\"square\">\r\n                <input type=\"text\" value={coreSquare.clue} onChange={onClueChange} />\r\n            </div>\r\n            );\r\n    }\r\n    else if (onSelect) {\r\n        const onClick: () => void = () => {\r\n            onSelect(index)\r\n        };\r\n        \r\n        let className=\"square\";\r\n        if(coreSquare.selected) {\r\n            className += \" selected\";\r\n        }\r\n        if(coreSquare.solvedGroup) {\r\n            className += \" group\" + coreSquare.solvedGroup;\r\n        }\r\n\r\n        return (\r\n            <div\r\n                onClick={onClick}\r\n                className={className}\r\n                >\r\n                {coreSquare.clue}\r\n            </div>\r\n            );\r\n    }\r\n    else {\r\n        throw Error(\"Oops\");\r\n    }\r\n}\r\n\r\n\r\ninterface WallProps {\r\n    coreSquares: Array<CoreSquare>,\r\n    onChange?: (index: number, clue: string) => void,\r\n    onSelect?: (index: number) => void,\r\n};\r\n\r\nconst Wall: FC<WallProps> = ({ coreSquares, onChange, onSelect }: WallProps) => {\r\n    return (\r\n        <div className=\"wall\">\r\n            {coreSquares.map((cs: CoreSquare, index: number) => (\r\n                <Square \r\n                    key={index.toString()} \r\n                    index={index}\r\n                    coreSquare={cs}\r\n                    onChange={onChange}\r\n                    onSelect={onSelect}\r\n                />\r\n            ))}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Wall;","// Shuffle array in place. Return the shuffled array\r\nexport function shuffleArray<T>(array: Array<T>) {\r\n    // From https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    return array;\r\n  }\r\n  \r\nexport  class DumbEncrypt {\r\n    private static readonly  prime = 19793;\r\n  \r\n    static doInt(val: number) {\r\n      const encrypted = val * this.prime +\r\n        Math.floor(Math.random() * this.prime);\r\n  \r\n      if(this.undoInt(encrypted) !== val) {\r\n        throw new Error(`DumbEncypt.doInt Cannot encrypt ${val}`);\r\n      } \r\n      return encrypted;\r\n    }\r\n  \r\n    static undoInt(val: number) {\r\n      return Math.floor(val / this.prime);\r\n    }\r\n  };\r\n\r\n","import React, { FC, useState} from 'react';\r\nimport Wall  from './wall';\r\nimport { shuffleArray, DumbEncrypt } from './tools';\r\nimport './App.css';\r\n\r\n// Remove unsuitable characeters from clue\r\nfunction filterClue(clue: string) {\r\n  // For now at least just remove '~' as that has special meaning in\r\n  // the URLs that are generated. \r\n  return clue.replace(/~/g, \"\");\r\n}\r\n\r\nlet startingClues: Array<string>;\r\n// startingClues = [\r\n//   'a1', 'a2', 'a3', 'a4',\r\n//   'b1', 'b2', 'b3', 'b4',\r\n//   'c1', 'c2', 'c3', 'c4',\r\n//   'd1 longlonglong', 'd2', 'd3', 'd4',\r\n// ];\r\n\r\nconst groupSize = 4;\r\nconst nGroups = 4;\r\nconst nSquares = groupSize * nGroups;\r\n\r\nfunction groupFromIndex(index: number) {\r\n  return Math.floor(index/groupSize) + 1;\r\n}\r\n\r\nclass CoreSquare {\r\n  readonly answerGroup: number;\r\n  clue: string;\r\n  selected = false; \r\n  solvedGroup: number | null = null;\r\n\r\n  constructor(answerGroup: number, clue=\"\") {\r\n    this.answerGroup = answerGroup;\r\n    this.clue = clue;\r\n  }\r\n};\r\n\r\n\r\nfunction makeUrlParams(squares: Array<CoreSquare>) {\r\n\r\n  let urlParams = new URLSearchParams();\r\n\r\n  let clues=\"\";\r\n  squares.forEach(s => clues += s.clue + \"~\");\r\n  urlParams.append(\"clues\", clues.slice(0, -1));\r\n\r\n  console.log(\"answer group values\", squares.map(s  => s.answerGroup));\r\n  let key = 0;\r\n  squares.forEach(s => key = key * nGroups + s.answerGroup);\r\n  const encrypted = DumbEncrypt.doInt(key);\r\n  urlParams.append(\"key\", encrypted.toString());\r\n  return urlParams;\r\n}\r\n\r\nfunction unpackURLClues(urlParams: URLSearchParams) {\r\n\r\n  const urlClues = urlParams.get(\"clues\");\r\n  if(urlClues) {\r\n    const clues = urlClues.split(\"~\");\r\n    \r\n    if(clues.length === nSquares) {\r\n      return clues;\r\n    } else {\r\n      console.log(\"Did not find the expected number of clues\", clues);\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction unpackURLSolutionGroups(urlParams: URLSearchParams) {\r\n  let values: Array<number> | null = null;\r\n\r\n  const urlKey = urlParams.get(\"key\");\r\n  if (urlKey) {\r\n\r\n    let combinedValues = DumbEncrypt.undoInt(parseInt(urlKey));\r\n\r\n    values = [];\r\n    for (let i = 0; i < nSquares; ++i) {\r\n      const value = combinedValues % nGroups;\r\n      combinedValues = (combinedValues - value) / nGroups;\r\n      values.push(value);\r\n    }\r\n    values.reverse();\r\n\r\n    // Check the values.  There should be groupSize values for each group.\r\n    for (let g = 0; values && g < nGroups; ++g) {\r\n      const matched = values.filter(k => k === g);\r\n      if (matched.length !== groupSize) {\r\n        console.log(\"Cannot interpret urlKey\", urlKey);\r\n        values = null;\r\n      }\r\n    }\r\n\r\n    console.log(\"Group values\", values);\r\n  }\r\n\r\n  return values;\r\n}\r\n\r\nlet startingSquares: Array<CoreSquare> = [];\r\nlet cluesSetByURL: boolean;\r\n\r\nfunction processURLParams() {\r\n\r\n    const urlParams = new URLSearchParams(window.location.search);\r\n    \r\n    const urlClues = unpackURLClues(urlParams);\r\n    const urlSolutionGroups = unpackURLSolutionGroups(urlParams);\r\n    \r\n    cluesSetByURL = false;\r\n    if(urlClues && urlSolutionGroups) {\r\n      cluesSetByURL = true;\r\n      \r\n      for(let i = 0; i < nSquares; ++i) {\r\n        startingSquares.push(\r\n          new CoreSquare(urlSolutionGroups[i], urlClues[i])\r\n        );\r\n      }\r\n    }\r\n    else {\r\n      if(urlParams.toString()) {\r\n        alert(\"Could not understand URL parameters\");\r\n      }\r\n\r\n      for (let groupNo = 0; groupNo < nGroups; ++groupNo) {\r\n        for (let n = 0; n < groupSize; ++n) {\r\n          let s = new CoreSquare(groupNo);\r\n          startingSquares.push(s);\r\n\r\n          // To help with testing\r\n          if (startingClues) {\r\n            s.clue = startingClues[n + groupNo * groupSize];\r\n          }\r\n        }\r\n      }\r\n    }\r\n}\r\n\r\nprocessURLParams();\r\n\r\n\r\n// Check that \r\n// - Squares in solved groups below 'groupBeingProcessed' are correctly placed\r\n// = No square is in a solved group greated than  'groupBeingProcessed'\r\n// Throw an error the if check fails.\r\nfunction sanityCheckSolvedGroups(squares: Array<CoreSquare>, groupBeingProcessed: number) {\r\n  for (let index = 0; index < squares.length; ++index) {\r\n    const positional = groupFromIndex(index);\r\n    const current = squares[index].solvedGroup;\r\n    if(positional < groupBeingProcessed) {\r\n        if(positional !== current) {\r\n          throw new Error(`square ${index} is not in solved group ${positional}`)\r\n        }\r\n\r\n        if (current > groupBeingProcessed) {\r\n          throw new Error(`square ${index} is in unexpected solved fron ${current}`)\r\n        }\r\n    }\r\n  }\r\n}\r\n\r\nfunction positionSquaresInSolvedGroup(squares: Array<CoreSquare>, groupNo: number) {\r\n\r\n  sanityCheckSolvedGroups(squares, groupNo);\r\n\r\n  // Relies on properties cheched above. \r\n  for (let index = 0; index < squares.length; ++index) {\r\n    const sq = squares[index];\r\n    if (sq.solvedGroup === groupNo && groupFromIndex(index) !== groupNo) {\r\n      const moveTo = squares.findIndex(s => !s.solvedGroup); // Inefficient\r\n      if (groupFromIndex(moveTo) !== groupNo) {\r\n        throw new Error(\"Bah! Something has gone wrong\");\r\n      }\r\n      [squares[index], squares[moveTo]] = [squares[moveTo], squares[index]];\r\n    }\r\n  }\r\n}\r\n\r\n\r\nconst App: FC<{}> = () => {\r\n\r\n  const [coreSquares, setCoreSquares] = useState(startingSquares);\r\n  const [lastSolvedGroup, setLastSolvedGroup] = useState(0);\r\n\r\n  const clueChange: (index: number, newClue: string) => void = (index, newClue) => {\r\n    let newSquares = [...coreSquares];\r\n    newSquares[index].clue = filterClue(newClue);\r\n    setCoreSquares(newSquares);\r\n  }\r\n\r\n  const finishedEnteringWords: () => void = () => {\r\n    const shuffled = shuffleArray([...coreSquares]);\r\n    const urlParams = makeUrlParams(shuffled);\r\n    //const urlParams = makeUrlParams(coreSquares);\r\n    window.open(window.location.href + \"?\" + urlParams.toString());\r\n  }\r\n\r\n  const clueSelected: (index: number) => void = (index) => {\r\n\r\n    // Ignore squares that have already been solved.\r\n    if(cluesSetByURL && !coreSquares[index].solvedGroup) {\r\n      let squares = [...coreSquares];\r\n      squares[index].selected = !squares[index].selected;\r\n\r\n      let selected = squares.filter(cs => cs.selected);\r\n      if(selected.find(s => s.solvedGroup)) {\r\n        throw new Error(\"Selected square is already solved\");\r\n      }\r\n\r\n      if( selected.length === groupSize ) {\r\n        selected.forEach(s => s.selected = false);\r\n\r\n        if (selected.every(s => s.answerGroup === selected[0].answerGroup)) {\r\n          const solvedGroup = lastSolvedGroup + 1;\r\n          setLastSolvedGroup(solvedGroup);\r\n\r\n          selected.forEach(s => s.solvedGroup = solvedGroup);\r\n          positionSquaresInSolvedGroup(squares, solvedGroup);\r\n\r\n           // If the last but one group has been solve, then the last group \r\n          // must also be solved.\r\n          if(solvedGroup + 1 === nGroups) {\r\n            squares.forEach(s => {\r\n              if(!s.solvedGroup) {\r\n                s.solvedGroup = nGroups;\r\n              }\r\n            })\r\n            setLastSolvedGroup(nGroups);\r\n          }\r\n        }\r\n      }\r\n\r\n      setCoreSquares(squares);\r\n    }\r\n  }\r\n\r\n  if (cluesSetByURL) {\r\n    return (\r\n      <div className=\"onlyconnect\">\r\n        <Wall coreSquares={coreSquares} onSelect={clueSelected}/>\r\n      </div>\r\n      )\r\n  } else {\r\n    return (\r\n      <div className=\"onlyconnect\">\r\n        <Wall coreSquares={coreSquares} onChange={clueChange} />\r\n        <div className=\"controls\">\r\n          <button type=\"button\" onClick={finishedEnteringWords}>Done</button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n};\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './app';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}