{"version":3,"sources":["wall.tsx","solving-area.tsx","setting-area.tsx","tools.ts","app.tsx","reportWebVitals.ts","index.tsx"],"names":["Square","coreSquare","index","onSelect","className","selected","badGuess","solvedGroup","onClick","clue","Wall","coreSquares","map","cs","toString","SolvingArea","hasGuess","hasBadGuess","clueSelected","doClearGuess","clearGuessButton","type","trimmed","words","console","log","result","i","t","trim","push","SettingArea","recordClues","useState","recordedText","setRecordedText","errorMessage","setErrorMessage","ErrorMessage","cols","rows","onChange","event","target","value","spaceSeparated","split","length","commaSeparated","text","getCluesCommaSeperated","DumbEncrypt","val","encrypted","this","prime","Math","floor","random","undoInt","Error","filterClue","replace","groupFromIndex","CoreSquare","answerGroup","cluesSetByURL","startingSquares","positionSquaresInSolvedGroup","squares","groupNo","groupBeingProcessed","positional","current","sanityCheckSolvedGroups","moveTo","findIndex","s","urlParams","URLSearchParams","window","location","search","urlClues","get","clues","groupSize","unpackURLClues","urlSolutionGroups","values","urlKey","combinedValues","parseInt","reverse","g","filter","k","unpackURLSolutionGroups","alert","n","processURLParams","App","setCoreSquares","cluesEntered","setCluesEntered","lastSolvedGroup","setLastSolvedGroup","useEffect","document","title","Boolean","find","forEach","every","newSquares","ResultArea","append","slice","key","doInt","makeUrlParams","array","j","shuffleArray","url","href","coreSquares_","group","cluesSet","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.7254bb48.chunk.js","sourcesContent":["import React, { FC } from 'react';\r\n\r\n\r\ninterface CoreSquare {\r\n    clue: string;\r\n    selected: boolean;\r\n    badGuess: boolean;\r\n    solvedGroup: number | null;\r\n};\r\n\r\ninterface SquareProps {\r\n    coreSquare: CoreSquare;\r\n    index: number;\r\n    onSelect?: (index:number) => void;\r\n}\r\n\r\nconst Square : FC<SquareProps> = ({coreSquare, index, onSelect}: SquareProps) => {\r\n  \r\n    const onClick: () => void = () => {\r\n        if(onSelect)\r\n            onSelect(index)\r\n    };\r\n\r\n    let className = \"square\";\r\n    if (coreSquare.selected) {\r\n        className += \" selected\";\r\n    }\r\n    if (coreSquare.badGuess) {\r\n        className += \" bad-guess\";\r\n    }\r\n    if (coreSquare.solvedGroup) {\r\n        className += \" group\" + coreSquare.solvedGroup;\r\n    }\r\n\r\n    return (\r\n        <div\r\n            onClick={onClick}\r\n            className={className}\r\n        >\r\n            {coreSquare.clue}\r\n        </div>\r\n    );\r\n\r\n}\r\n\r\n\r\ninterface WallProps {\r\n    coreSquares: Array<CoreSquare>,\r\n    onSelect?: (index: number) => void,\r\n};\r\n\r\nconst Wall: FC<WallProps> = ({ coreSquares, onSelect }: WallProps) => {\r\n    return (\r\n        <div className=\"wall\">\r\n            {coreSquares.map((cs: CoreSquare, index: number) => (\r\n                <Square \r\n                    key={index.toString()} \r\n                    index={index}\r\n                    coreSquare={cs}\r\n                    onSelect={onSelect}\r\n                />\r\n            ))}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Wall;\r\nexport type { CoreSquare }","import React from 'react';\r\nimport Wall, { CoreSquare } from './wall'\r\n\r\n\r\ninterface SolvingAreaProps {\r\n    coreSquares: Array<CoreSquare>\r\n    hasGuess: boolean;\r\n    hasBadGuess: boolean;\r\n    clueSelected: (index: number) => void,\r\n    doClearGuess: ()=>void;\r\n}\r\n\r\nfunction SolvingArea({coreSquares, hasGuess, hasBadGuess, clueSelected, doClearGuess} : SolvingAreaProps) {\r\n\r\n     const clearGuessButton = (\r\n        <button type=\"button\" onClick={doClearGuess}>\r\n            Clear guess\r\n        </button>\r\n    );\r\n\r\n    return (\r\n        <>\r\n            <Wall\r\n                coreSquares={coreSquares}\r\n                onSelect={clueSelected}\r\n            />\r\n            <div className=\"controls\">\r\n                {hasGuess ? clearGuessButton : null}\r\n                {hasBadGuess ? <div>Wrong!</div> : null}\r\n            </div>\r\n        </>\r\n    );\r\n} \r\n\r\nexport default SolvingArea;","import React, {useState} from 'react';\r\n\r\nfunction trimmed(words: Array<string>) {\r\n    console.log(\"Pre-trimmed\", words);\r\n\r\n    let result : Array<string> = [];\r\n    for(let i in words) {\r\n        const t = words[i].trim();\r\n        if (t) {\r\n            result.push(t);\r\n        } \r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction getCluesSpaceSeperated(text: string) {\r\n    return trimmed(text.split(/[,\\s]/));\r\n}\r\n\r\n// Find non-empty clues separated by commas or newlines\r\nfunction getCluesCommaSeperated(text: string) {\r\n    return trimmed(text.split(/[,\\n]/));\r\n}\r\n\r\ninterface SettingAreaProps {\r\n    recordClues: (clues: Array<string> | null) => void;\r\n}\r\nfunction SettingArea({recordClues} : SettingAreaProps)\r\n{\r\n    const [recordedText, setRecordedText] = useState(\"\");\r\n    const [errorMessage, setErrorMessage] = useState(\"\");\r\n\r\n\r\n    function textAreaChange(event: any) {\r\n        setRecordedText(event.target.value);\r\n    }\r\n\r\n    function onDone() {\r\n        setErrorMessage(\"\");\r\n\r\n        const spaceSeparated = getCluesSpaceSeperated(recordedText);\r\n        console.log(\"Space separated\", spaceSeparated);\r\n        if(spaceSeparated.length === 16) {\r\n            recordClues(spaceSeparated);\r\n            return;\r\n        } \r\n        \r\n        const commaSeparated = getCluesCommaSeperated(recordedText);\r\n        console.log(\"Comma separated\", commaSeparated);\r\n\r\n        if(commaSeparated.length === 16) {\r\n            recordClues(commaSeparated);\r\n            return;\r\n        } \r\n\r\n        setErrorMessage(`Did not find 16 clues: \r\n            ${spaceSeparated.length} found with space seperation.\r\n            ${commaSeparated.length} found with comma-seperation.`     \r\n        );\r\n\r\n        \r\n    }\r\n\r\n    const ErrorMessage = () => {\r\n        if(errorMessage) {\r\n            return <div>{\"Error: \" + errorMessage}</div>\r\n        }\r\n        return null;\r\n    }\r\n    \r\n    return (<>\r\n        <div>\r\n            <p>Enter clues.  These can be single words, or words and phrases seperated by commas</p>\r\n            <textarea  \r\n                cols={50}\r\n                rows={4}\r\n                onChange={textAreaChange}\r\n            />\r\n        </div>\r\n        <button onClick={onDone}>Done</button>\r\n        <ErrorMessage/>\r\n    </>);\r\n}\r\n\r\nexport default SettingArea;","// Shuffle array in place. Return the shuffled array\r\nexport function shuffleArray<T>(array: Array<T>) {\r\n    // From https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\r\n    for (let i = array.length - 1; i > 0; i--) {\r\n        const j = Math.floor(Math.random() * (i + 1));\r\n        [array[i], array[j]] = [array[j], array[i]];\r\n    }\r\n    return array;\r\n  }\r\n  \r\nexport  class DumbEncrypt {\r\n    private static readonly  prime = 19793;\r\n  \r\n    static doInt(val: number) {\r\n      const encrypted = val * this.prime +\r\n        Math.floor(Math.random() * this.prime);\r\n  \r\n      if(this.undoInt(encrypted) !== val) {\r\n        throw new Error(`DumbEncypt.doInt Cannot encrypt ${val}`);\r\n      } \r\n      return encrypted;\r\n    }\r\n  \r\n    static undoInt(val: number) {\r\n      return Math.floor(val / this.prime);\r\n    }\r\n  };\r\n\r\n","// TO DO:  Tidy this code so it less of a dogs dinner.\r\nimport React, { FC, useEffect, useState} from 'react';\r\nimport SolvingArea from './solving-area'\r\nimport SettingArea from './setting-area'\r\nimport { shuffleArray, DumbEncrypt } from './tools';\r\nimport './App.css';\r\nimport Wall from './wall';\r\n\r\n// Remove unsuitable characeters from clue\r\nfunction filterClue(clue: string) {\r\n  // For now at least just remove '~' as that has special meaning in\r\n  // the URLs that are generated. \r\n  return clue.replace(/~/g, \"\");\r\n}\r\n\r\nlet startingClues: Array<string>;\r\n// startingClues = [\r\n//   'a1', 'a2', 'a3', 'a4',\r\n//   'b1', 'b2', 'b3', 'b4',\r\n//   'c1', 'c2', 'c3', 'c4',\r\n//   'd1 longlonglong', 'd2', 'd3', 'd4',\r\n// ];\r\n\r\nconst groupSize = 4;\r\nconst nGroups = 4;\r\nconst nSquares = groupSize * nGroups;\r\n\r\nfunction groupFromIndex(index: number) {\r\n  return Math.floor(index/groupSize) + 1;\r\n}\r\n\r\nclass CoreSquare {\r\n  readonly answerGroup: number;\r\n  clue: string;\r\n  selected = false;\r\n  badGuess = false; \r\n  solvedGroup: number | null = null;\r\n\r\n  constructor(answerGroup: number, clue=\"\") {\r\n    this.answerGroup = answerGroup;\r\n    this.clue = filterClue(clue);\r\n  }\r\n};\r\n\r\n\r\nfunction makeUrlParams(squares: Array<CoreSquare>) {\r\n\r\n  let urlParams = new URLSearchParams();\r\n\r\n  let clues=\"\";\r\n  squares.forEach(s => clues += s.clue + \"~\");\r\n  urlParams.append(\"clues\", clues.slice(0, -1));\r\n\r\n  let key = 0;\r\n  squares.forEach(s => key = key * nGroups + s.answerGroup);\r\n  const encrypted = DumbEncrypt.doInt(key);\r\n  urlParams.append(\"key\", encrypted.toString());\r\n  return urlParams;\r\n}\r\n\r\nfunction unpackURLClues(urlParams: URLSearchParams) {\r\n\r\n  const urlClues = urlParams.get(\"clues\");\r\n  if(urlClues) {\r\n    const clues = urlClues.split(\"~\");\r\n    \r\n    if(clues.length === nSquares) {\r\n      return clues;\r\n    } else {\r\n      console.log(\"Did not find the expected number of clues\", clues);\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction unpackURLSolutionGroups(urlParams: URLSearchParams) {\r\n  let values: Array<number> | null = null;\r\n\r\n  const urlKey = urlParams.get(\"key\");\r\n  if (urlKey) {\r\n\r\n    let combinedValues = DumbEncrypt.undoInt(parseInt(urlKey));\r\n\r\n    values = [];\r\n    for (let i = 0; i < nSquares; ++i) {\r\n      const value = combinedValues % nGroups;\r\n      combinedValues = (combinedValues - value) / nGroups;\r\n      values.push(value);\r\n    }\r\n    values.reverse();\r\n\r\n    // Check the values.  There should be groupSize values for each group.\r\n    for (let g = 0; values && g < nGroups; ++g) {\r\n      const matched = values.filter(k => k === g);\r\n      if (matched.length !== groupSize) {\r\n        console.log(\"Cannot interpret urlKey\", urlKey);\r\n        values = null;\r\n      }\r\n    }\r\n  }\r\n\r\n  return values;\r\n}\r\n\r\nlet startingSquares: Array<CoreSquare> = [];\r\nlet cluesSetByURL: boolean;\r\n\r\n// KLUDGE - Use to set gloabls. Would be better called in the App.\r\nfunction processURLParams() {\r\n\r\n    const urlParams = new URLSearchParams(window.location.search);\r\n    \r\n    const urlClues = unpackURLClues(urlParams);\r\n    const urlSolutionGroups = unpackURLSolutionGroups(urlParams);\r\n    \r\n    cluesSetByURL = false;\r\n    if(urlClues && urlSolutionGroups) {\r\n      cluesSetByURL = true;\r\n      \r\n      for(let i = 0; i < nSquares; ++i) {\r\n        startingSquares.push(\r\n          new CoreSquare(urlSolutionGroups[i], urlClues[i])\r\n        );\r\n      }\r\n    }\r\n    else {\r\n      if(urlParams.toString()) {\r\n        alert(\"Could not understand URL parameters\");\r\n      }\r\n\r\n      for (let groupNo = 0; groupNo < nGroups; ++groupNo) {\r\n        for (let n = 0; n < groupSize; ++n) {\r\n          let s = new CoreSquare(groupNo);\r\n          startingSquares.push(s);\r\n\r\n          // To help with testing\r\n          if (startingClues) {\r\n            s.clue = startingClues[n + groupNo * groupSize];\r\n          }\r\n        }\r\n      }\r\n    }\r\n}\r\n\r\nprocessURLParams();\r\n\r\n\r\n// Check that \r\n// - Squares in solved groups below 'groupBeingProcessed' are correctly placed\r\n// = No square is in a solved group greated than  'groupBeingProcessed'\r\n// Throw an error the if check fails.\r\nfunction sanityCheckSolvedGroups(squares: Array<CoreSquare>, groupBeingProcessed: number) {\r\n  for (let index = 0; index < squares.length; ++index) {\r\n    const positional = groupFromIndex(index);\r\n    const current = squares[index].solvedGroup;\r\n    if(positional < groupBeingProcessed) {\r\n        if(positional !== current) {\r\n          throw new Error(`square ${index} is not in solved group ${positional}`)\r\n        }\r\n\r\n        if (current > groupBeingProcessed) {\r\n          throw new Error(`square ${index} is in unexpected solved fron ${current}`)\r\n        }\r\n    }\r\n  }\r\n}\r\n\r\nfunction positionSquaresInSolvedGroup(squares: Array<CoreSquare>, groupNo: number) {\r\n\r\n  sanityCheckSolvedGroups(squares, groupNo);\r\n\r\n  // Relies on properties cheched above. \r\n  for (let index = 0; index < squares.length; ++index) {\r\n    const sq = squares[index];\r\n    if (sq.solvedGroup === groupNo && groupFromIndex(index) !== groupNo) {\r\n      const moveTo = squares.findIndex(s => !s.solvedGroup); // Inefficient\r\n      if (groupFromIndex(moveTo) !== groupNo) {\r\n        throw new Error(\"Bah! Something has gone wrong\");\r\n      }\r\n      [squares[index], squares[moveTo]] = [squares[moveTo], squares[index]];\r\n    }\r\n  }\r\n}\r\n\r\n\r\nconst App: FC<{}> = () => {\r\n\r\n  const [coreSquares, setCoreSquares] = useState(startingSquares);\r\n  const [cluesEntered, setCluesEntered] = useState(false);\r\n\r\n  const [lastSolvedGroup, setLastSolvedGroup] = useState(0);\r\n  useEffect(()=>{document.title = \"OnlyConnect\"});\r\n\r\n  \r\n  const cluesSet = (clues: Array<string>) => {\r\n    const coreSquares_ = clues.map((clue, index) => {\r\n      const group = Math.floor(index/4);\r\n      return new CoreSquare(group, clue);\r\n    }); \r\n    setCoreSquares(coreSquares_);\r\n    setCluesEntered(true);\r\n  }\r\n\r\n\r\n  const clueSelected: (index: number) => void = (index) => {\r\n\r\n    // Ignore squares that have already been solved.\r\n    if(cluesSetByURL && !coreSquares[index].solvedGroup) {\r\n      let squares = [...coreSquares];\r\n      squares.forEach(s => s.badGuess = false);\r\n      squares[index].selected = !squares[index].selected;\r\n\r\n      let selected = squares.filter(cs => cs.selected);\r\n      if(selected.find(s => s.solvedGroup)) {\r\n        throw new Error(\"Selected square is already solved\");\r\n      }\r\n\r\n      if( selected.length === groupSize ) {\r\n        selected.forEach(s => s.selected = false);\r\n\r\n        if (selected.every(s => s.answerGroup === selected[0].answerGroup)) {\r\n          const solvedGroup = lastSolvedGroup + 1;\r\n          setLastSolvedGroup(solvedGroup);\r\n\r\n          selected.forEach(s => s.solvedGroup = solvedGroup);\r\n          positionSquaresInSolvedGroup(squares, solvedGroup);\r\n\r\n           // If the last but one group has been solve, then the last group \r\n          // must also be solved.\r\n          if(solvedGroup + 1 === nGroups) {\r\n            squares.forEach(s => {\r\n              if(!s.solvedGroup) {\r\n                s.solvedGroup = nGroups;\r\n              }\r\n            })\r\n            setLastSolvedGroup(nGroups);\r\n          }\r\n        } else {\r\n          selected.forEach(s => s.badGuess = true);\r\n        }\r\n      }\r\n\r\n      setCoreSquares(squares);\r\n    }\r\n  }\r\n\r\n  const hasGuess = Boolean(coreSquares.find(s => (s.selected || s.badGuess)));\r\n  const hasBadGuess = Boolean(coreSquares.find(s => s.badGuess));\r\n\r\n  const doClearGuess = () => {\r\n    let newSquares = [...coreSquares];\r\n    newSquares.forEach(s => {\r\n      s.badGuess = false;\r\n      s.selected = false;\r\n    });\r\n    setCoreSquares(newSquares);\r\n  }\r\n\r\n  if(cluesSetByURL) {\r\n    return (<SolvingArea\r\n      coreSquares={coreSquares} \r\n      hasGuess={hasGuess}\r\n      hasBadGuess={hasBadGuess}\r\n      clueSelected={clueSelected}\r\n      doClearGuess={doClearGuess}\r\n    />);\r\n  }\r\n\r\n  const ResultArea = () => {\r\n    const shuffled = shuffleArray([...coreSquares]);\r\n    const urlParams = makeUrlParams(shuffled);\r\n    const url = window.location.href + \"?\" + urlParams.toString();\r\n    return (\r\n      <div>\r\n        <Wall coreSquares={coreSquares} />\r\n        <div> <a href={url} target=\"blank\">Randomised (Playable)</a> </div>\r\n      </div>);\r\n  }\r\n\r\n  const recordClues = (clues: Array<string> | null) => {\r\n      if(clues) {\r\n        cluesSet(clues);\r\n      } else {\r\n        setCluesEntered(false);\r\n      }\r\n  }\r\n\r\n  return (\r\n    <div className=\"onlyconnect\">\r\n      <SettingArea recordClues={recordClues} />\r\n      {cluesEntered ? <ResultArea/> : null}\r\n    </div>\r\n  )\r\n};\r\n\r\nexport default App;\r\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);  \n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n}\n\nexport default reportWebVitals;\n","import React from 'react';\r\nimport ReactDOM from 'react-dom';\r\nimport './index.css';\r\nimport App from './app';\r\nimport reportWebVitals from './reportWebVitals';\r\n\r\nReactDOM.render(\r\n  <React.StrictMode>\r\n    <App />\r\n  </React.StrictMode>,\r\n  document.getElementById('root')\r\n);\r\n\r\n// If you want to start measuring performance in your app, pass a function\r\n// to log results (for example: reportWebVitals(console.log))\r\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\r\nreportWebVitals();\r\n"],"sourceRoot":""}